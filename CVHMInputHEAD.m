function CVHMInputHEAD(startTime, endTime, opt)

% startTime, endTime are [1x2] matrices [y m]

if ~isfield(opt,'cbcf_path')
    opt.cbcf_path = '../CVHM_DATA/ClaudiaRun/';
end
if ~isfield(opt, 'std_Htol')
    opt.std_Htol = 5;
end

% ======== load Data
% This has been generated by running the first sections of the
% HydraulicHeadAnalysis script
load('HeadAnalysisData.mat', 'LNS_IJ', 'PNTS')
load([opt.cbcf_path 'HEADS.mat'])
load([opt.cbcf_path 'CBCdaily.mat'])
load([opt.gis_path 'BAS_active_shp.mat']);
load('BufferPnts.mat')
% make unique list of buffer outline points
buff_pnt = [buff(1,1).X(1) buff(1,1).Y(1)];
for ii = 1:length(buff(1,1).X) - 1
    dst = sqrt((buff_pnt(:,1) - buff(1,1).X(ii)).^2 + (buff_pnt(:,2) - buff(1,1).Y(ii)).^2);
    if min(dst) > 0.1
        buff_pnt = [buff_pnt; buff(1,1).X(ii) buff(1,1).Y(ii)];
    end
end

istart = find(CBCdaily.ym(:,1) == startTime(1) & CBCdaily.ym(:,2) == startTime(2));
iend = find(CBCdaily.ym(:,1) == endTime(1) & CBCdaily.ym(:,2) == endTime(2));
timestring = [num2str(startTime(1)) 'm' num2str(startTime(2)) '_'  num2str(endTime(1)) 'm' num2str(endTime(2))];
clear CBCdaily % we dont need this variable here just for the time stamp

% For each time step compute the top most head value
clear TOPHEAD toplay
cnt = 1;
for it = istart:iend
    it
    TOPHEAD{cnt,1} = nan(size(HEADS{1,1},1), size(HEADS{1,1},2));
    toplay{cnt,1} = nan(size(HEADS{1,1},1), size(HEADS{1,1},2));
    for ii = 1:size(HEADS{1,1},1)
        for jj = 1:size(HEADS{1,1},2)
            for kk = 1:size(HEADS{1,1},3)%:-1:1
                if HEADS{it,1}(ii,jj,kk) ~= HEADS{1,1}(1,1,1)
                    TOPHEAD{cnt,1}(ii,jj) = HEADS{it,1}(ii,jj,kk);
                    toplay{cnt,1}(ii, jj) = kk;
                    break
                end
            end
        end
    end
    cnt = cnt + 1;
end

% Calculate average head and Standard deviation
head_std = nan(size(HEADS{1,1},1), size(HEADS{1,1},2));
head_Av = nan(size(HEADS{1,1},1), size(HEADS{1,1},2));
for ii = 1:size(HEADS{1,1},1)
    for jj = 1:size(HEADS{1,1},2)
        temp = nan(length(TOPHEAD),1);
        for kk = 1:length(TOPHEAD)
            temp(kk,1) = TOPHEAD{kk,1}(ii,jj);
        end
        head_std(ii,jj) = std(temp);
        head_Av(ii,jj) = mean(temp);
    end
end

% Assign head values to segments
LNS_IJ = [LNS_IJ nan(size(LNS_IJ,1),2)];
for ii = 1:size(LNS_IJ, 1) - 1
    r = LNS_IJ(ii,1);
    c = LNS_IJ(ii,2);
    temp = nan(length(TOPHEAD),1);
    for kk = 1:length(TOPHEAD)
        temp(kk,1) = TOPHEAD{kk,1}(r, c);
    end
    LNS_IJ(ii,3:4) = [mean(temp) std(temp)];
end

% Interpolate the head and standard deviations values on the nodes
PNTS = [PNTS nan(size(PNTS,1),2)];
for ii = 1:size(PNTS,1)-1
    if ii == 1
        % if this is the first we average the first and last segments
        PNTS(ii,3:4) = [(LNS_IJ(1,3) + LNS_IJ(end-1,3) )/2 (LNS_IJ(1,4) + LNS_IJ(end-1,4) )/2];
        PNTS(end,3:4) = [(LNS_IJ(1,3) + LNS_IJ(end-1,3) )/2 (LNS_IJ(1,4) + LNS_IJ(end-1,4) )/2];
    else
        PNTS(ii,3:4) = [(LNS_IJ(ii,3) + LNS_IJ(ii-1,3) )/2 (LNS_IJ(ii,4) + LNS_IJ(ii-1,4) )/2];
    end
end

% Define the number of boundary functions based on the head standard deviation
cnt_bnd = 0;
clear BND_LINES
next_line = 1;
for ii = 1:size(PNTS,1)
    if PNTS(ii,4) < opt.std_Htol
        if next_line == 1
            cnt_bnd = cnt_bnd + 1;
            BND_LINES{cnt_bnd,1} = [];
            next_line = 0;
        end
        BND_LINES{cnt_bnd,1} = [BND_LINES{cnt_bnd,1}; ii];
    else
        next_line = 1;
    end
end
% remove the segments with length 1
dlt = [];
for ii = 1:length(BND_LINES)
    if length(BND_LINES{ii,1}) == 1
        dlt = [dlt; ii];
    end
end
BND_LINES(dlt,:) = [];

if ~exist([opt.simFolder filesep 'BC_files'], 'dir')
    mkdir([opt.simFolder filesep 'BC_files']);
end

% write the file using boundary function
fid = fopen([opt.simFolder filesep opt.prefix '_' timestring  '_BC.npsat'], 'w');
fprintf(fid, '%d\n', length(BND_LINES));
for ii = 1:length(BND_LINES)
    fprintf(fid, 'EDGETOP 0 BC_files/%s\n', ['bnd' timestring '_h' num2str(opt.std_Htol) '_' num2str(ii) '.npsat']);
    
    fid1 = fopen([opt.simFolder filesep 'BC_files' filesep 'bnd' timestring '_h' num2str(opt.std_Htol) '_' num2str(ii) '.npsat'], 'w');
    fprintf(fid1, 'BOUNDARY_LINE\n');
    fprintf(fid1, '%d %d %f\n', [length(BND_LINES{ii,1}) 1 1]); % Npnts Ndata tolerance
    fprintf(fid1, '%f %f %f\n', PNTS(BND_LINES{ii,1},1:3)');
    fclose(fid1);
end
fclose(fid);

% Use the average of Head for the simulation period as top function.
% Loop through the modflow grid cells and find the center coordinate of the
% cell in the real system
R = [bas_active.ROW]';
C = [bas_active.COLUMN_]';
xy_top = [];
for ii = 1:size(head_Av, 1)
    for jj = 1:size(head_Av, 2)
        id = find(R == ii & C == jj);
        if isempty(id)
            continue;
        elseif length(id) == 1
            xc = mean(bas_active(id,1).X(1:end-1));
            yc = mean(bas_active(id,1).Y(1:end-1));
            xy_top = [xy_top; xc yc head_Av(ii,jj)];
        else
            error('Thats so wrong');
        end
    end
end

% add the buffer nodes.
% create an interpolant with the existing data
Ftop = scatteredInterpolant(xy_top(:,1), xy_top(:,2), xy_top(:,3));
Ftop.Method = 'nearest';
Ftop.ExtrapolationMethod = 'nearest';
buf_val = Ftop(buff_pnt(:,1), buff_pnt(:,2));
xy_top = [xy_top; buff_pnt buf_val];
writeScatteredData([opt.simFolder filesep opt.prefix '_' timestring  '_Top.npsat'], struct('PDIM',2,'TYPE','HOR','MODE','SIMPLE'), xy_top);